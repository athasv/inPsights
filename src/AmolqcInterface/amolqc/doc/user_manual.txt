
  * * * User Manual for amolqc * * *

This manual describes tersely most of the options
of the amolqc program and its utilities. For the
appropriate usage check the examples and tests.

Contents:

1. Installation and Usage
1.1 Installation
1.2 Usage
2. Description of the infile (.in)
3. Description of the wavefunction file (.wf)
4. Utility programs
4.1 g09forAmolqc.py (generates initial amolqc wf file from gaussian)
4.2 runConvertBasisFile.py (converts basis sets from emsl or gaussian format to amolqc format)
5. amolqc basis set library

Note: throughout this manual, [xxx] denotes an optional parameter xxx where
a default value is supplied if xxx is not given
Alternative values are indicated by '|', thus [a|b] means 'a' or 'b' can be given.

1. Installation and Usage
=========================

1.1.1 Installation
==================

tar xzvf amolqcXXXX.tgz
creates a directory amolqc with subdirectories

cd amolqc
adapt one of the .cfg files in configs to local
settings of Compiler, MPI, LAPACK, and the desired optimization
and parallization level.

in amolqc run:
./configure yourfile.cfg
make -jn
"n" denotes number of processors you use for compiling(namely -j4)
To do a quick test
make tests
For more test option check "testsuite/README"
The executable is
src/amolqc

1.1.1 Installation
==================

 This options may be appended to the $AMOLQC/rules.mk file

 RNG = X   : Replaces RAN2 random nember generator with X
           where X can be MT(Mersenne Twister) or MRG.

FFLAGS, FNOFLAGS and F90FLAGS:

 -DWTIMER  : Calculates wall clock time evaluation for individual parts of the
            code.
            This flag should be apended to both "FFLAGS" and "F90FLAGS",
            i.e.
              F90FLAGS += -DWTIMER
              FFLAGS   += -DWTIMER

 -DCHKNANUP : Checks for NANs in Sherman Morrison updates and do ordinary
             determinant evaluation instead for these excited determinants.
             This flag should be apended to "F90FLAGS" only
              F90FLAGS += DCHKNANUP

1.2 Usage
=========

usage:

/path/to/amolqc infile

where "infile.in" exists in the current directory and contains commands including a
line '$wf(read,file=name.wf)' requiring a wavefunction file
'name.wf' in the same directory. No output is generated. Instead, the output
is written into the file 'infile.out'. If this file exists it is overwritten without
a comment.

Some commands require access to files of the amolqc installation. These files are
found relative to the contents of the environment variable $AMOLQC that has to
be set to the root of the installation (usually named 'amolqc' as well).
The environment variable is set as usual with
export AMOLQC=/path/to/amolqc-directory
in bash shells. Put this line into your .profile or .bashrc and in your queue job script
prior to the amolqc command.




2. Description of infile (.in file)
===================================

Infile contains commands of the structure
$name(options)
or comment lines starting with "!"

Commands are allowed in any order, but $gen and $wf have to precede
any qmc command.

In this manual optional values are given with "[optional]" and
alternative values with "|", e.g.
[[no]splineaos]   means: either "nosplineaos" or "splineaos" may be given here,
  but neither is necessary (because there is a default value)
[splineaos|nosplineaos]    means: the same alternative, but one of the two has to
  be given.
[[splineaos|nosplineaos]]   means: the same as the first example.


Besides the commands listed below, a loop structure and a macro expansion
exists:

2.1 Loop structure:

$begin_loop(count=n)
...
[$exit_if(condition[,stop])]
[$stop_if(condition)]
...
$end_loop

The commands between $begin_loop and $end_loop are carried out n times.
Optionally, the $exit_if command allows exiting the loop and continuing after
$end_loop is 'condition' is fullfilled. If the keyword 'stop' is given, the
job is terminated. The same is achieved with $stop_if(condition).
conditions: [energy<ddd|energy>ddd|variance<ddd|variance>ddd]
ddd is a real number. More than one condition can be given. They are combined
with "or". Energy and variance values used in the comparison are the final result of
the last "$qmc" or "$optimize_parameters" command.
The $exit_if/$stop_if command is useful to terminate divergent parameter optimizations.

2.2 Macro expansion:

If a command "$command" is not implemented, it is checked if a macro command
file with the name "command.cmd" exists in directory cmds. If it does the
content of command.cmd replaces $command. IF arguments are given, the
corresponding arguments in command.cmd are replaced with the new values
(but: command replacement happens only in command lines beginning with "x")
The macro expansion (with replacements) is printed in the output file.
If no file command.cmd exists the program aborts with an error message.


2.3 infile commands:

====================================================================================

$analyze_refs
-------------

analyzes the electron configurations from a ref file.
Prints out function value (-ln(psi**)), E_loc and V_pot
(both are NaN at singularities, E_loc is finite only if
singularity is removed exactly.)
Prints coordinates, gradients and electrons at nuclei
Prints eigenvalues
TODO: run optionally Nelder/Mead with all coordinates to check is true minimum

ref_file=name.ref : ref file name must be given
ref_n=0           : 0: analyze all i,1 refs with i=1,...; n: analyze all n,i refs
maxrefs=100       : do not analyze more than maxrefs refs.
verbose=2         : control output
nuc_thresh=0.002  : identify all electrons closer to a nuc as being at the nuc
h=0.001           : denominator for three-point numerical deriv (from grad) in Hessian

(This uses only the MASTER node)

====================================================================================

$change_jastrow
---------------

new_jastrow=jt where jt is the jastrow type (sm0,sm1,sm2,sm3,sm31,sm4,sm41,
                                             icXYZ where X,Y,Z >= 0,
                                             deXYZ where X,Y,Z >= 0)

      [params=paramFile]  reading Jastrow parameters from file containing a
                        $jastrow .. $end block

diff_ee_cusp: keyword to enable usage of different ee cusp condition for spin
        like and spin unlike electron electron terms in Jastrow factor
            see Chapter 3 - "Input of Jastrow Parameters" for details

same_ee_cusp: default
        keyword to disable usage of different ee cusp condition for spin
        like and spin unlike electron electron terms in Jastrow factor
          currently not implemented

add_aniso_terms : Adds anisotropic terms to Jastrow factor
        Implementation require to definde Jastrow first and then add anisotropic
        terms in second "change_jastrow" call
        format:
          $change_jastrow(add_aniso_terms,
          <keyword> [additional parameters; depend on keyword used]
          )
        line breaks are essential
        <keyword>: ao all , ao nuc, ao idx
                ao all:
                    adds and uses all basis functions of given l
                      format: ao all <functions>
                    choice of l = p, d, f
                    must be seperated by white space in case more than one function
                    shall be used (e.g. "p d" or "p d f")
                ao nuc:
                    adds and uses all basis functions for given l and nucleus
                      format: <number of lines>
                              <function> <center> [<center1_2> ... ]
                              <function2> <center2> [<center2_2> ... ]
                              ...
                          seperated by line breaks, only one l added in each line
                          (i.e. two lines needed for adding p and d functions)
                ao idx:
                    adds and uses given basis function (given by indicies)
                      format: <number of basis functions>
                              <index of basis function1> <index of basis function2>
                          seperated by white space or line break

====================================================================================

$change_parameters
------------------
options: type, mode
2nd line: contains idx parameter value pairs.
idx1 val1 idx2 val2 ...

====================================================================================
$ce

Uses the ce file from energy partitioning to calculate the energy contributions for defineable
chemical entities (ce). The definition is stored in a filed named definition.ce.

readce         : read definition from file, no alternative implemented at the moment
ce_print_full  : prints ce energies and E_int_ne,E_int_ee,E_int_kin,..., E_ww_ee, E_ww_ne, E_ww_nn....
debug		   : gives causes ce to print details for debugging

definition.ce FORMAT :

2   !Number of ces
O   !Name for ce
1   !Numer of cores in ce
1   !Index of core in geometry (s. wf-file)
2   !Number of electrons in the ce
2 1 !Indizes of electrons in the reference (s. ref file or better in front of the vmc calculation in out)
LP  ! Example for lonepair and case of no cores (same for no electrons in ce)
0   ! no cores
0   ! no indizes
2
3 4

=====================================================================================

$ecp
----

initializes and turns on use of ECPs. $ecp must be after the $wf block.
options:
det_only: ECP localization without Jastrow factor
full_localisation: ECP localization with Jastrow factor(default)
[no_]random_rotation: use [fixed] random axis system for grid integration
cutoff=x: if given, ECP cutoff is turned on. This calculates for each atom
  a cutoff radius for the non-local part. The calculated radii are shown with
  verbose>=2.
[full|no|nonlocal]_cutoff: Cutoff for all channels (local and non-local)
                           no cutoff Cutoff only for non-local channels(default)
grid_points=n: Set same integration grid points for all atoms.
grid_point_list=m: Set integration grid points for different atoms.
  a n
               which sets the integration grid points for atom a to n.


====================================================================================

$eloctest
---------
tests the eloc code by calculating contributions like Jastrow, Phi to Eloc
and additionally testing the derivatives with numerical derivatives.

options: h,rule,points,derivatives,updatetest

h=x  where x is a small real number (default: 1.d-5) for difference quotients
rule=n  3-point, 5-point or 7-point rule for numerical differentiation
points=n use the first n points in sample for test
derivatives: calculate derivatives numerically
updatetest: check updating electrons
====================================================================================


$find_maxima:

activates a search for (all important) local maxima of psi**2 (with the 3n dimensional
many-electron wavefunction psi).
For all but the smallest molecules, the number of local maxima of psi**2 is large.
Therefore, the global maximum is only of limited interest, and the goal is to analyze
all local maxima of importance. This requires collecting (and counting) maxima according
to certain criteria (see below).
The collected maxima will be written to basename.ref
The .ref file contains reference structures (usually local maxima) identified by two
indices: n and m. This is to be understood as a main list (index n) where each entry
is a sublist (index m). Some modes of $find_maxima use only the main list, i.e. (n,m) =
(1,1), (2,1), (3,1) ... (nmax,1) but most use sublists.
Maxima are identified as minima of f = - ln(psi**2)
find_maxima uses sampling of psi**2 with VMC and a local minimum search at each block end.
For the master, the exit codes of the minimizer are collected and printed
at the end as percentage. The meaning of the error codes differ for the methods.

keywords:
   all $qmc(vmc) keywords for vmc run
	 nmax=30         : restricts length of the main list to nmax. Further data are ignored
   mmax=1          : restricts length of the sublists to mmax.
   method = lbfgs|bfgs|nelm : optimizer, lbfgs is now default (nelm==Nelder/Mead)
   block_stride=1   : run local minimizer every "block_stride" blocks
   max_iter=200   : max # of iterations in optimizer

   bfgs parameters:
     step_max=1.d0  : max step size in bfgs
     numgrad        : if given, use numerical gradients
     tol=0.001      : defines when two maxima are equal based on function values |F(max1)-F(max2)| <= tol
                    : the tolerance for the optimizer will be set to tol/10, which has numerical reasons
   [no_]core_sep  : defines treatment of cores: core_sep (default): put 2 elecs on nuc for Z>2

   exit codes: 0: gradient converged (tol/10)
               1: distance converged (internal criterion)
               2: no convergence in max_iter steps
               3: minimization aborted because ftheta is 'not a number'

   lbfgs parameters:
     (currently, lbfgs puts always the closest 2 elecs at all nuclei > He)
     convergence when *all* criteria are fullfilled:
     max_grad=1.d-6   : max gradient (component)
     max_dist=1.d-5   : max distance (length of bfgs direction vector)
     max_f   =1.d-6   : max change of function value (from previous step)
     H_dist  = -1.d0  : if elec is closer to H (or He) nucleus than "H_dist",
                        elec is put at nucleus and removed from minimization (new: in A)

     The very many local maxima can be collected in various ways controlled by max_mode.
     The collected maxima are saved in the text file basename.ref. The format should be fairly obvious.
     Each maximum is denoted with n,m corresponding to list index and sublist index.

     max_mode=[val|vst|str|pos] default: "val"

        parameters: (not all used in all modes)
             nmax=30              restricts length of the main list to nmax. Further data are ignored
             mmax=5               restricts length of sub lists to mmax.
             tol_fctn=0.001       two function values (-ln(psi**2)) are identified as the same if the differ
                                  by less than tol_fctn
             tol_same=0.01        two electron arrangements are identified as the same if the maximal distance
                                  between two corresponding positions is less than tol_same (new: in A)
             tol_sim=0.1          two electron arrangements are identified as the similar if the maximal distance
                                  between two corresponding positions is less than tol_sim (new: in A)
             sort_freq            if given, sort references w.r.t. frequency (instead of value) at output (out and ref)

        val: "value" mode.
             main list contains local maxima sorted w.r.t the function value, i.e. -ln(psi**2).
             maxima with "same" function value are collected and only counted (not stored).
             tolerance "tol_fctn" defines "same". ref file contains sorted list of maxima where
             the last entry has the summed count of all remaining (discarded) maxima!
             sub lists are not used, i.e. m=1 for all entries.

        vst: "value/structure" mode. parameters:
             same as val, but now for each function value a sublist (maximal length mmax) is created.
             Entries are structures that differ by more than tol_same. More precisely: a new local
             maximum with the same function value is compared with all structures in the sublist by finding
             the best assignment (treating alpha and beta electrons as different) and then determining the
             maximal distance for all assigned electrons. If max distance is smaller than tol_same, the
             count for that structure is increased. If no structure matches the new local maximum, a new
             entry is added to the sublist (more than mmax are ignored)

        str: "structure" mode. addtnl parameters:
             excl_file=filename

             main list (max size nmax) contains different "structures". Two maxima are understood as
             having the same structure if they are "similar" when the spin is ignored. "Similarity" is
             determined by tol_sim (max distance of two corresponding positions)
             The list of structures is sorted w.r.t the function value (1st index n in ref file). For
             each structure in the list a (sub)list is maintained the collects identical (same)
             maxima including identical spin. Maxima are identified as the same if the maximum distance
             between to corresponding positions is less than tol_same.
             The sublist for each structure contains thus the spin permutations of the structure.
             The sublists are also sorted w.r.t the function value.

             excl_file is an optional argument. If given a file containing "electrons to be excluded"
             from the determination of maximum distance (for comparison with tol_sim and tol_same).
             The file is a text file with the structure
               n
               code1
               ...
               coden
             where n is the number of excluded positions, and "code" is a simple integer code of the form:
             abbcc with
               a=1: at nucleus  a=2: within core a=3: along a bond a=4: between two atoms (but not along bond)
               a=5: all others (i.e. lone pair)
               bb and cc are two digit form of the element number (01=H, 06=C, 18=Ar, ...). for a=1,2,5 bb=00
               Ex.: 10001: position at any H nucleus
                    30601 and 30106: position along any CH bond.

        pos: "position" mode. Parameters:
             tol_simmax=tol_sim
             ref_file=file_name.ref
             excl_file=filename
             ignore_ref_elecs=n

             like in "str" mode, identical structures irrespective of spin are identified (with tol_sim). In pos
             mode, however, the entries in the main structure list are read from the ref_file. More precisely,
             The structure list is initialized with the entries (n=1,m=1), (2,1), ... (nmax,1) from file_name.ref.
             It is useful to use file_name.ref from an "str" run, use the same tol_sim as in that run, and
             restrict nmax to the interesting structures of the previous run.
             In the "pos" mode all electron positions are collected
             and averaged. For this a list of electron positions is constructed for each "structure". For each
             new maximum all electrons are compared with the positions of the list. If an electron is closer than
             tol_simmax (defaults to tol_sim) to a position in the list,
             this electron is added to this position (meaning doing statistics over electron positions).
             If not, a new entry in the position list is added.
             All positions for each structure are printed at the end of the $find_maxima run, with std dev and
             std error. They are also saved as basename.max in a format similar to the .ref format.
             The ref_file is used to create the initial electron position lists, and it is used to assign electrons
             of a maximum (of one structure) to the ref_file electrons, now with spin preserved. This way the two
             possible position of an electron due to spin permutations are found, and thus electron pairs are
             identified (because of they occupy the same two positions in closed shell molecules) if they exist.
             We average over the position of each electron in the reference structure after assignment, i.e. we average
             over the two possible positions of each pair. The mean is calculated with a weight proportional to
             the probability (psi**2) of the local maximum relative to the global maximum (from the reference file).
             The averaged positions are saved as .ref file.

             This is done by comparing each electron arrangement with that of the reference
             (ref_file), after renumbering

             excl_file for list of excluded positions, see "str"
             ignore_ref_elecs=n
             $find_maxima(blocks=20,steps=200,max_iter=150,max_mode=pos,nmax=3,max_full=20,
               ref_file=ethene-max1p.ref,ignore_ref_elecs=8,tol_maxdist=0.1,tol_pos=0.1,H_dist=0.1
                  3
                 3 4 6 8  11 12 15 16
                 3 4 6 7  11 12 13 15
                 3 4 5 7  11 12 14 15
               )
             this means: 8 electrons are ignored when determining maxdist and meandist for 3 ref structures
             (see nmax=3). Each line contains the number of the electron in the reference file (here: ethene-max1.ref).
             After identifying the positions using e.g. matlab, the above list of electrons assigned to the given
             electrons of the reference can be constructed.


   exit codes: 0: all three criteria converged
               1: gradient not converged
               2: distance not converged
               3: function value not converged
               4: minimization aborted with internal error (e.g. line search not conv)

    nelm parameters:
      border = 20.0   : ?? limits for parameters
      delta =  0.2    : initial step width for electron positions
      tol=0.001       : tests only function value convergence with tol/10

    exit codes: 0: converged (only the function value convergence is checked!)
                1: not converged

$gen
----
options: verbose,seed

verbose=[0,1,2,3,4,5,6]: standard output is 2, walker based output with 5

seed=n: initialization of random number generator (uses the seeds n,n+1,...n+nproc-1, where
        nproc is the # of MPI processes)

====================================================================================

$iterate_coc

options like in $qmc, since it runs several qmc calculations
center of charge (coc) specific options:

non optional keywords:

  readref or ref_file  (see sed)
  ref_nr               (see sed)
  iters=3              (max number of) iterations
  coc_tol=1.e-3        convergence criterium for components in coc iterations
  coc_mtol=coc_tol/10  convergence criterium for components in coc calculation

optional keywords:

  coc_average (experimental, currently disabled): is given, cocs are calculated as average of cocs
             Sometimes the coc does not converge to the desired crit. but oscillate.
				 In this case one can make the statistics over the calculated coc's to obtain
				 an accurate estimate. This can be also useful in order to run the calculation with lower
				 tolerances.
  coc_discard=2        number of coc steps to discard before averaging

=====================================================================================


$max_domain_init
----------------

triggers initialization of cube files for domain sampling. Domain sampling is done in subsequent
$find_maxima call. Note: Currently find_maxima is called at the end of each block. Change to step_stride
like in $sed.

parameters:
   write_xyz: if given write all walkers assigned to a reference in ref-format (filename: basename.xyz)
             file contains assigned reference number for each walker. Walker are written in permuted form
             (as assigned to reference)
   grid=4d0       : defines a cube [-grid,-grid] in x,y,z direction, i.e. around the origin (no default)
   ax=,bx=,ay=,by=,az=,bz= : give explicit coordinates of the cube (more precisely: cuboid!)
   ref_file=filename : read reference from other file
   nbin=80        : sets the number of bins in each direction of the grid
   sbin=0	      : creates a subcube around the center of mass of the cube data of each maximum position
					with the size of 2*sbin+1 in each direction. sbin>0 enables the creation of the
					subcube


$optimize_parameters
--------------------
options: energy_min|variance_min,params,method,optmode,eq_iter

params=[jastrow|ci|mo|jas+ci|jas+mo|mo+ci,jas+mo+ci]
        The order is important.
energy_min: (minimization w.r.t. the sample energy)
  method=[newton|scaled_newton|lm_newton|tr_newton|eminlin|popt] default is lm_newton
   newton: simple several Newton-Raphson energy minimization
   scaled_newton: Newton step is scaled w.r.t a cost function
   lm_newton: Levenberg-Marquardt Newton step. Hessian is modified to ensure it is positive definite
   tr_newton: trust-region Newton-Raphson energy using the DNMTR code (newton or eminlin is preferable)
   eminlin: linear energy minimization as suggested by C. Umrigar with scaling step
   popt: perturbative energy minimization Toulouse, Umrigar 2007
variance_min: (minimization w.r.t. the sample variance)
  method=[varmin|lm] default is varmin
   varmin: variance minimization using the NL2SOL code
   lm: variance minimization using Levenberg-Marquardt algorithm (varmin is preferable)

optmode=[1|2|3|4|5]: which parameters to optimize (default: 1)
  the meaning of the optmode depends on the parameter set being used:
  jastrow:
    ic|de:  1: linear parameters (analytical derivatives)
            2: linear parameters (numerical derivatives)
            3: nonlinear parameters (numerical derivatives)
            4: all parameters (lin. analytical, nonlin. numerical)
            5: all parameters (numerical)
    sm:     1: linear parameters
            2: linear + nonlinear parameters
    dtn:    1: linear + nonlinear parameters
            2: linear parameters
  ci: ???

options for params=mo:
  mo_param_mode=[1|2] default: 2
            1: successive 2x2 rotations
            2: rotation matrix = exp(kappa)
  mo_update_mode=[1|2] default: 2
            1: excited determinants directly
            2: excited determinants with Sherman-Morrison

options for all methods:

eq_iter=n: equilibrate sample and iterate n times.

eq_call=subname: expects a $begin_subroutine(name=subname) ... $end_subroutine block
  at the beginning of the in-script, containing the commands to equilibrate the sample
  default: subname=equilibrate (allowing named subroutines in "cmds" is not yet implemented)

wf_write: write the wf file for the parameters of each iteration step

varmin options:
  E_ref=dd:  reference energy(Optional but recommended).In case of absence,
    emean+emean*0.02 for first optimization cycle and emean for rest cycles will
    be used as E_ref. Note that "emean" is Sample's mean, local energy.
  E_ref_adp (optional):  adapts reference energy using samples mean energy after
    each opt cycle.
  E_ref_fix (optional,default):  use fixed reference energy
  max_iter=3: iterations with fixed sample (default: 3)
  max_iter=n: iterations with fixed sample (e.g. in varmin1 and varmin2)
    it's not usualy needed for varmin2, you only need to specify max_iter=2 if you had difficulties(diverged parameters) in optimizing paramiters.
  NL2SOL_D_mode=[0,1]: NL2SOL scale vector mode (varmin2).default is "0".  Only needed when no changes in parameters.
 mo_noise_coeff=0.0  : Add gaussian white noise fo starting orbital rotation params aroung
                        zero (startin params will be mo_noise_coef* g_rand ).
lm options:
  E_ref=dd:  reference energy(Optional but recommended). In case of absence,
    emean+emean*0.02 for first optimization cycle and emean for rest cycles will
    be used as E_ref. Note that "emean" is Sample's mean, local energy.
  E_ref_adp (optional):  adapts reference energy using samples mean energy after
    each opt cycle.
  E_ref_fix (optional,default):  use fixed reference energy.
  max_iter=3: iterations with fixed sample (default: 3)
  lambda=0.001: value of lambda in varmin1. The diagonal elements are scaled with 1+lambda, lambda is
                increased by a factor of 10 with each itaration that didn't succeed in decreasing the variance.

newton options:
  max_var=1.d9: terminate optimization iterations if this variance is reached
  nrmethod=1: Standard Newton-Raphson, no further options
  nrmethod=2: Use scaled Newton-Raphson step, step length obtained from fixed sample
    target_E, target_var: required to determine step length
    dmax=1.d9: fixed trust radius (mean abs component of parameter vector delta_p). delta_p is forced below this
               threshold
    cffac=1.d0: scaling factor variance in cost function (abs(delta_E) + cffac*abs(delta_var))
  nrmethod=3: Levenberg-Marquardt Newton stop with distance control
    nu=0.001: Actual Hessian in Newton step is H' = H + nu*Imat (Imat=unit matrix). nu is initial value for nu.
      nu is adapted to achieve a ratio of predicted/true energy change
      of better than 0.25, and to achieve positive definite H'.
    delta_f_min=0.d0: if set do not change nu if the change in the fixed sample energy is smaller than delta_f_min
      (because of the unavoidable random noise in the fixed sample energy)

eminlin options   :
  E_lb=dd         : lower bound for eigenvalue selection : currently disabled
  max_Im=1.d-3    : max allowed value for imaginary part for eigenvalue selection : currently disabled
  max_ev=5        : eigenvalue selection by choosing lowest fixed sample variance of the lowest max_ev eigenvalues
  ev_sample_size= : use a subset of samples to evaluate correct eigenvalue and parameters vector length

popt options                :
max_var=1.d9                : terminate optimization iterations if this variance is reached
write_de                    : writes delta E in file with .dat extension
delta_e=                    : sets a fixed delta E for all parameters
delta_e_[once|always]       : calculates the delta E for one or all iterations(default)
delta_e_sample_size=        : use a subset of samples to calculate delta E
delta_e_filename='filename' : reads delta E array from the file.

====================================================================================

$optimize_refs
--------------

read a .ref file and optimize all references (using LBFGS only)

ref_file= ref file
new_file= ref file to save all optimized references
verbose=2
max_grad=1.d-5   : max gradient (component)
max_dist=1.d-4   : max distance (length of bfgs direction vector)
max_f   =1.d-5   : max change of function value (from previous step)
H_dist  = -1.d0  : if elec is closer to H (or He) nucleus than "H_dist (in bohr)",
                   elec is put at nucleus and removed from minimization
                   <0: do nothing
                   if too small, LBFGS tends to fail near H nuclei (due to
                   singularity). Sensible values are 0.1 .. 0.3 (smaller than
                   half a bond length: H-H has half bond length 0.6)


====================================================================================

$optimtest
----------
tests the parameter derivatives using numerical derivatives (difference quotients)
options: type,mode,h,rule

type='jastrow'|'ci'|'jas+ci'  selects parameter
mode=1|2|3          optMode
h=x  where x is a small real number (default: 1.d-5) for difference quotients
rule=n  3-point, 5-point or 7-point rule for numerical differentiation



====================================================================================

$params_numderivs
-----------------

options: type,mode,h and vmc options
2nd line contains list of parameters (defined by their index) for which derivative
is to be calculated.

type='jastrow'|'ci'|'jas+ci'
mode=1|2|3 optMode
h=x where x is a small real number (default: 1.d-2) for difference quotients

this calculates vmc gradient and diagonal hessian for selected parameters
using 3-point rule with h

====================================================================================

$print_results
-------------

no options

prints table of saved results (see $save_result)

====================================================================================

$qmc
----
options: [vmc|dmc]

vmc|dmc           : set appropriate defaults for VMC and DMC
steps=10          : steps in one block
blocks=10         : # of blocks (or maximum # of blocks if std_dev is given)
std_dev=0.05      : if given stop calculation if standard deviation is obtained
E_ref=0.0         : (initial) reference energy for weighting. if not given use total energy
                    from previous run (usually VMC)
walker_block=1    : calculate blocks of walkers "simultaneously" (allow use of
                      certain optimizations and efficient use of a GPU)
time step options
tau=              : time step, if given time step adaptation is turned off, no default
initial_tau=0.01  : initial time step for time step adaptation
accept_ratio=0.5  : adapt time step to obtain given accept ratio (no initial time step required)
                    default for VMC: 0.5, for DMC: 0.9

persist=nn        : remove "persistent" walker after nn rejected steps (
discard=5         : blocks to discard for averagin data
drift_scal=1.0    : scale the drift vector
move=[rey|umr|two|gss]    : Reynolds, Umrigar, Two level Gaussian, and
                            simple Gaussian propagation step for VMC and DMC. Two level and
                            Gaussian are only valid for VMC (see twolevel.in) : new default: umr
weight=[rey|umr|acc] : Reynolds or Umrigar weighting (or accept weighting): new default: umr
no_exp            : do not use exponential sampling in Umrigar propagator
show_steps        : write block,step,E,var,stddev for each step to fort.900
[no_]load_balance : turn on/off load_balancing between nodes
no_auto_corr      : turn off calculation of autocorrelation of energy data
auto_corr_max=500 : set array size (=steps) for autocorrelation calculation. Turn on calculation

epart             : turns on the energy partitioning for a certain reference.
   - cestat : turns on the "on the fly" chemical entity (ce) evaluation
                             : a definition.ce file with ce definiton ist needed for this one (s. $ce )
                             : currently on the E_int and E_ww values for a ce are calculated

accumulate        : Accumulates all samples created by propagating the current walkers.
                    After the qmc block is done, the current sample refers to the
                    accumulated history, so that any optimizations/SED calculations
                    are then done with the accumulated history instead of the actual
                    VMC walkers.
                    acc_step and acc_discard.
acc_step=5        : How many steps have to pass between walkers being added to the
                    history. acc_step=10 means, that every 10th sample is added
                    to the history.
                    The total number of accumulated samples after a VMC run is
                       number of cores * accumulation sample size * floor(steps / acc_step) * blocks
                    where accumulation sample size is the size of the sample that's being used in
                    the accumulation run.
acc_size=10000    : Total accumulation size per core(optional).
acc_discard       : How many steps should be discarded in *each* block before walkers
                    are added to the history.

For an example usage of the accumulation, see examples/h_accumulate.in

====================================================================================

$sample
-------

modi: [create|read|change_size|histogram|remove_outliers]

modi with options:
create
   size=n: when create: create sample of size n
read
   pos_file=filename: read sample from file
   size=n: up to size n (per process)
change_size
   new_size=n: sets sample size to new value (by deleting or randomly copying)
   last: only keep the last n walkers. Useful in combination with $qmc(accumulate,...)
histogram
   - histogram of current sample is write to "basename"-histnn.txt where nn is increased with
     each call to histogram. verbose>=3 writes histogram for each MPI process: "basename"tid-histnn.txt
     histogram contains mean(!) of bin, bin weight, expected weight according to normal dist. with same mean/var.
   histogram_width=fac: [fac=5.0] histogram interval [mean-fac*sqrt(var), mean+fac*sqrt(var)]
   bins=n: [n=20] number of bins
remove_outliers
   two implementations: algo=[1|2], default is 2

   algo=1: for large samples only: remove outliers in local sample iteratively
   remove_factor=rf: [rf=10.0] remove outliers repeatedly until the # of outliers is less
                     than rf x expected # of data (in normal distribution)
   iterations=it [it=100] only outliers in outermost bins are removed in each iterations.
                     Iterate until no outliers are found or "it" is reached
   histogram_width=fac: [fac=5.0] histogram interval [mean-fac*sqrt(var), mean+fac*sqrt(var)]
   bins=n: [n=20] number of bins

   algo=2: for all samples: remove outliers parallel using the trimmed mean of global sample
   [global|local]:  use global (i.e. all nodes) or local (per node) sample to determine outliers.
                    default is global
   no_replace:      default is to replace removed walkers by random copies of surviving walkers.
                    no_replace prevents the replacement.
   tol=tl           [tl=3.0] tolerance for survival: all walkers outside mean+/-tl*sigma are removed.
                    Note that mean and sigma are calculated with the 10% trimmed sample (first and
                    last 10% ignored).

options:
generate=[vmc|random|single_point], default: random
   vmc: requires tau, steps [discard]. one walker vmc run to generate sample
   random: random positions
   single_point: generate size=n walkers all at same position (init_walker or random)

start: how to start walker generation
start=[gaussian,density[,lmo]], default: density
   gaussian: simple gaussian distribution around nuclei
   density: do simple density sampling for each atomic shell (only neutral closed shell)
      rspread=rs: vary shell radius randomly with mean percentage rs
   lmo: to be implemented

E_min=xxx,E_max=yyy select only those random walkers in the given energy interval
verbose=n   verbosity in $sample

====================================================================================

$save_result
-------------

options: 'idx=$idx' or 'idx=n'

save (E,stddev,var) from the last calculation. Currently this works for $qmc
and for $optimize_parameters. In the latter case only E and var are calculated
(!) and the stddev is set to zero. The default index is the next index
(starting from 1) unless idx=n is used. idx=$idx uses the loop index of
$begin_loop.
Use $print_results() tp print the full table of saved results

====================================================================================

$sed
----

activates a sed calculation within a qmc run
   qmc run is controlled by the qmc parameters (see $qmc)
   step_stride=nn : run sed assignment only every nn-th step [default: nn=1]
   grid=4d0       : defines a cube [-grid,-grid] in x,y,z direction, i.e. around the origin (no default)
   ax=,bx=,ay=,by=,az=,bz= : give explicit coordinates of the cube (more precisely: cuboid!)
   readref        : read reference from ref file with same base name
   ref_file=filename : read reference from other file
   nbin=80        : sets the number of bins in each direction of the grid
   ref_nr=1       : can be used to choose a reference from the ref-file
                    assignment parameters:
   write_xyz      : write all permuted walkers to local file(s) in ref-format


$wf
---
options: [[read|write]],file,[la_mode=n],[[no_]splineaos],[[no_]cuspcor],[spline_points=n],[aosopt],
[[no_]aomo],[ao_cutoff=xxx],[mo_cutoff=xxx],[task],[prod_cutoff=xxx],[fastdet]

read|write: read or write wavefunction file.

file='fname.wf' containing the wavefunction to read or write. Use 'write'
to save wavefunctions after optimizations. If the filename contains '$idx',
every occurence is replaced with the current $begin_loop() index (or 1, if no
loop is active). '$in' is replaced with the basename of the input file.

these options for reading the file:

la_mode=n: 1: BLAS in update inverse, 2: BLAS in MO calculation, 4: LAPACK LU decomp.
  (i.e. 7=1+2+4 is LAPACK/BLAS in all cases, 0 turned off). Default n=7.

[no_]splineaos: [do not] spline the atomic basis functions
  - this is currently possible only for GTOs. Default: splineaos when possible
[no_]cuspcor: [do not] correct the cusp at the nuclei.
  - this is possible (and sensible) only for GTOs. Default: cuspcor when possible
spline_points=n: change the # of spline points from default value
aosopt: special option, if given, the cusp correction parameters are calculated. The
  run is terminated afterwards. The calculated cusp correction parameters need to be
  added to the basis function definition. See Chapter xxx
epart: This is the command to initialize all data structures for the energy partitioning
task: Use the OpenMP parallelized version of the AOMO calculation. Requires aomo to be set.
      The environment variables OMP_NUM_THREADS determines the number of threads used for
      the calculation. For "normal" MPI calculations, where the number of processes is
      equal to the number of processor cores, this should be set to 1.
prod_cutoff: Requires aomo,task to be set. The cutoff value for MO-coeff * exp(-\alpha r^2).
fastdet: Uses the "fast" determinant calculation by Clark et al. (doi:10.1063/1.3665391).
         This is mainly useful when having many determinants (more determinants than electrons)
         with small excitations (i.e. mostly single and double excitations). Note that this
         cannot be used together with ECPs or with CSF input.
no_repeat_det_opt: Calculates all determinant in CSFs(as defaults we do not calculate
                     repeated determinants).


$write_sample
-------------

options: file=fname.pos

write the current sample to the file. If no file name is given the default
name 'basename.pos' is used. The data are written in binary format. Only the
positions of the walkers are written, not any weights. This is not intended
for check pointing (use serialization instead).
Works for parallel runs by writing the samples of each process in the order of
the MPI taskid.

Read sample with the $sample(read) command.


3. Description of wavefunction file (wf file)
=============================================

The default values for the wavefunction are defined in the file "wf_d.f90"
(But the may be overwritten before reading the .wf file in wf_m.d90; they should not)

Structure of wf file:
=====================

The wf file consists of the following blocks:
$general
$geom            # geometry
$jastrow         # required only when jastrow given
$basis           # atomic basis set, not required when library basis used
$mos             # MO coefficient matrix
$dets or $csfs   # Slater determinants and CI coefficients
Each block ends with $end

The order of the blocks is arbitrary, although the above order is
sensible.


$general
========
evfmt=[gau|gms|free|mol]   Gaussian, Gamess, free and Molden format (DESCRIBE!)
basis=[gaussian|general|diff|<basis_name>]
    gaussian: $basis block contains basis set in Gaussian format
    general: $basis block contains basis set in amolqc format
    diff: requires a basis set name for each atom in $geom block
    <basis_name>: if a basis name is given, the basis data are read from
                  a basis file named 'basis_name.abs' or, if the .abs
                  file does not exist, 'basis_name' in the directory
                  $AMOLQC/bib
                  The directory $AMOLQC/bib should contain pairs of
                  basis sets ending .abs and .gbs containing the same
                  basis in amolqc and Gaussian format. A python script
                  'runConvertBasis.py' is provided to convert basis sets
                  in different formats including the EMSL format.
jastrow=[none|sm|ic|de]
     where smxx is a Schmidt-Moskowitz Jastrow. The following forms are implemented:
           sm0|sm1|sm2|sm21|sm3|sm31|sm4|sm41
           jastrow=sm reads a general Schmidt-Moskowitz Jastrow in the old format
           ic is the new generalized power expansion of the Jastrow
           de is an alias for ic with the double exponential distance type
title='title string in apostrophes'
charge=n   total charge
spin=n     spin multiplicity (2S+1)
geom=[bohr|angstrom]   units for geometry (default:angstrom)
atomic_charges         geom contains a charge for each atom (helping initial sampling)
same_atoms_input       geom contains an index indicating atoms that are treated as identical
                       (currently used for same en terms in Jastrow)
no_hydrogen_jastrow    do not use en terms for H atoms
norm=[.true.|.false.] (default: .true.) Normalize the basis read from a $basis block.


$geom
=====

Format:

$geom
n
<line for 1st atom>
...
<line for n-th atom>
$end

The format for atom lines is quite flexible and depending on parameters in $general.
Only cartesian input is implemented. Use Gaussian/Molden/wxMacMolPlt ... to convert
Z matrix input to cartesian form. $general(geom) determines the units angstrom or bohr.
The atom line has the following format:
[sym|Z]  [sa]  x  y  z  [ch]  [bas]

with:
sym: atom symbol H,He ...
Z: atom number
sa: required when 'same_atoms_input' is given in $general. The sa ('same atom') values
 have to be integer values starting from one. Atoms with the same sa value share the
 electron-nucleus and electron-electron-nucleus Jastrow terms. The default behaviour is:
 All atoms with the same atomic number share the Jastrow terms. The sa values allow thus
 to optimize and use different Jastrow terms for the same atom, e.g. Carbonyl-C and
 Methyl-C can have different Jastrow terms when different sa values are used.
 Make sure that all given sa values cover the full interval [1..max(sa)]
ch: an integer charge that has to be supplied when 'atomic_charges' is given in $general.
 This is used to assign electrons to nuclei. The default behaviour
 is ch=0 for all atoms. The charge information is used only for generating initial electron
 configurations. Equilibration is accelerated by starting with fairly probable electron
 configurations. 'atomic_charges' is required for ions (to indicate _initially_ where the
 molecular charge is located) and might be required for molecules with strongly polar
 bonds.
bas: When 'basis=diff' is given in general, 'bas' is the basis name (from $AMOLQC/bib)
 used for this atom. This allows using easily different basis sets for different atoms.


$basis
===============

basis input:

$gen(basis=gaussian|general|<basisname>)

(a) basis=gaussian

generic gaussian format as in Gaussian program, additionally cusp correction
parameters, given in $basis block:

-------------------
$basis
<atom 1 block>
 ****
<atom 2 block>
 ****
...
<atom n block>
 ****
$end
-------------------

each <atom i block>:
-------------------
<atomname>
 <l> <ngto> <scal> [<cusp1> <cusp2> <cusp3> <cusp4>]
     <alpha_1> <c_1>
     ...
     <alpha_ngto> <c_ngto>
------------------
mit <atomname>  atom symbol or name. Same symbols will obtain use same
    spline interpolation function. Use e.g. "C1","C2" when different
    basis functions are used for same atom
    <l> : S|P|D  -type gaussian function. Note: <l> must be in 2nd column!
    <ngto> # of primitive gaussian functions
    <scal> scaling coefficient
    <cusp1> .. <cusp4>  optional cusp correction parameters
    <alpha_i>  orbital exponent
    <c_i>      contraction coefficient

where <cusp1> <cusp2> <cusp3> <cusp4> are the amolqc cusp correction
parameters a, c, p1, p2.


(b) basis=general

generic basis format allowing STO and GTO basis functions, given in $basis block

-------------------
$basis
<atom 1 block>
***
<atom 2 block>
***
...
<atom n block>
***
$end
-------------------

each <atom i block>:
-------------------
<atomname>
<l1> STO|GTO  <alpha1>
...
<ln> STO|GTO  <alphan>
-------------------
mit <li>=1S|2P|3D
    <alphai>  orbital exponent



(c) basis=<basisname>

where <basisname> is a string defining a basis set in the basis set library (see section 5)
(a directory defined by $AMOLQC/bib).
'basis=basisname' looks for a basis definition 'basisname.abs' in the basis set library.
Don't use the suffix '.abs' in the command line!


input of Slaterdeterminants
===========================

Antisymmetry of the wavefunction is enforced with Slaterdeterminant(s). There
are two variants for input of determinants: $dets and $csfs

$dets
n                          (( number of determinants))
ci-coeff occupied orbitals ((first alpha than beta spin))
(repeated n-1 times)
$end

example for RHF H2O (five orbitals doubly occupied)

$dets
1
1.0  1 2 3 4 5  1 2 3 4 5
$end

CSF input is similar, only the number of CSFs nCSF is given, followed by
CSF coeff and number of determinants in the CSF, followed by the coupling
coeffs and occupations. Example: 1 CSF with 2 determinants

$csfs
1
1.0 2
  0.707  1 2 3 4 5  1 2 3 4 6
  0.707  1 2 3 4 6  1 2 3 4 5
$end

input of Jastrow parameters
===========================

jastrow=ic|de:
-------------
<n_cores>
<nuc_cusp> <ee_cusp>
<u_max> <x_max> <f_max>
<ee_params>
<en_params 1>
<en_params 2>
...
<en_params x_max>
<een_params 1>
<een_params 2>
...
<een_params fmax>
[ <anisotric terms> ]
<dist_type>
<distance_params 1> <distance_params 2> ...
------------------
with
  <n_cores>: number of cores for jastrow (if 0, then number of atoms in molecule is used)
  <nuc_cusp>: T (true) ./. F (false) - satisfy nucleus-electron cusp exactly in jastrow
                               currently only .false. implemented
  <ee_cusp> : T (true) ./. F (false) - satisfy electron-electron cusp for spin like ee;
                      default: F (false)
                      false: same eecusp for spin like and spin-unlike ee pairs (1/2)
                      true : different eecusp for spin like (1/4) and spin unlike (1/2) ee pairs
                      details regaring cusp condition: doi: 10.1002/cpa.3160100201
  <u_max>: max degree of electron-electron terms
  <x_max>: max degree of electron-nucleus terms
  <f_max>: max degree of electron-electron-nucleus terms
  <ee_params>: u_max - 1 parameters (parameter for linear term is always 0.5)
  <en_params i>: x_max - 1 parameters for core i (parameter for linear term is always 0 or Z)
                 number of lines = n_cores
  <een_params i>: f_max parameters for core i, number of lines = n_cores
  <dist_type>: type of scaled distance to use (optional, default = 1 (2 if jastrow=de)):
               1 = SM-type
               2 = double exponential
               3 = needs type (r/(a+r^b))
  <distance_params i>: parameters for scaled distancs
                       if type = SM-type: 1 + n_core_types parameters
                          (A and B(:)),
                          default: all = 1d0
                       if type = double exp: 1 + n_core_types parameters
                          (\alpha and \beta(:)),
                          default: all = 1d0
                       if type = needs: 2 + 2*n_core_types parameters
                          (a_ee, a_en(:), b_ee, b_en(:)),
                          default: all = 1d0
  <anisotric terms>: may be added upon user request
                    format:
                      p function related parameters (3 parameters per p function per center)
                      d function related parameters (6 parameters per d function per center)
                      f function related parameters (10 parameters per f function per center)

4. Utility programs
===================

are found in the tools directory.
The python scripts require Python 2.7.

4.1 g09forAmolqc.py
===================

Run this python script in the directory where a gaussian
log file (from a geometry optimization) of the molecule
is available. No arguments required, the script is interactive.

4.2 runConvertBasisFile.py
==========================

without arguments the usage is printed.
For conversion of STO basis sets to .gbs (Gaussian basis set file format),
data for the expansion of STO into GTOs is required. Currently the only
file for conversion is 'sto2gto.dat'. It contains several expansions. The
best is 'OPT14' with 14 primitive GTOs per STO.
For conversion of an STO basis set in amolqc format (abs) into the gbs format
use:
../tools/runConvertBasisFile.py abs QZ4PAE.abs gbs QZ4PAE.gbs sto2gto.dat OPT14

Current limitation: no expansion for 4F functions available
(4F STO are also not yet implemented in amolqc)


5. Basis sets in amolqc
=======================

are defined in the bib directory. Some older files there may or may not work.
The current supported basis sets for amolqc have the '.abs' suffix. They are
paired with a '.gbs' file in the gaussian basis set format for gaussian calculations
to create the orbitals for amolqc.

Since amolqc has implemented STOs and GTOs (with STOs possibly faster than contracted GTOs)
STO basis sets are preferred for all electron calculations. The corresponding .gbs files
contain GTOs expansions of the STOs.

With the 'basis=general' or 'basis=gaussian' an arbitrary basis consisting of STOs and GTOs can be
defined.

List of supported basis sets:

CHAE:      Cade/Huo STO basis sets for highly accurate diatomic HF calculations
TZPAE:     TZP all electron STO basis set from ADF
QZ4PAE:    QZ all electron STO basis set with 4 pol functions from ADF (currently not usable due to 4F STOs)
QZ4PAE-f:  same without the 4F functions
S-311Gdp:  6-311G(d,p) with core function replaced by one STO (alpha optimized with UMP2 as in
           original 6-311G(d,p) article. Unpublished basis set.
cc-pVTZ:   Dunning's basis set, pure CGTO basis set
cc-pVTZ-f: same without f functions.
BFD-VTZ:  M. Burkatzki, C. Filippi, M. Dolg triple zeta basis for
          corresponding ECP.


