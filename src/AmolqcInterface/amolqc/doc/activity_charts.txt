amolqc: activity charts
=======================

flow thru code for various tasks:

(1) $find_maxima
(2) electron pair analysis
(3) wave function optimisation (NEEDS UPDATE)
(4) T move code

notations:
   $keyword
   <file>:<subroutine>
   | for subsequent action
   indenting for subaction

* data structures


===========================================

1) epart domain based

$max_domain_init(args):
|
maxdomain_m:maxdom_init:
   "epart" in args => epart_init
   mDoEpart = True
   |
   epartnew_m:epart_init:
      mDomain = "$sed" ? False : True
      allocate epart arrays/stat objects

------------------
$find_maxima(args):
|
qmc_m:qmc_init:
   mMaxSearch = True
   psimax_init
|
psimax_m:psimax_init:
   mEpart = maxdom_doEpart()
   create and initialize mRV_p reference vector object
   maxmode=="nil" => no mRC_p reference container object created
|
qmc_m:qmc_run:
   if (mMaxSearch.and.step==mBlockSize): psimax_opt()
   |
   psimax_m:psimax_opt:
      if (mEpart): psimax_addToEnergies  
   |
   psimax_m:psimax_addToEnergies:
      mRV_p%getIdxAndPermutation(n,idx2); idx2 -> asgn
      epart_add(rwp,asgn)
   |
   epart_write final result


notes: $find_maxima should change to $maxima_init and not include the qmc run
  use a step stride in qmc_run for psimax_opt calls and not a block stride, 
  allowing normal VMC calculation.


================================

(2) electron pair analysis: old/new

$max_domain_init(args):
|
maxdomain_m:maxdom_init
|
"elec_pair_analysis=" in args:
   mWriteEPairs = int

$find_maxima(args):
|
qmc_m:qmc_init:
   mMaxSearch = True
   psimax_init
|
psimax_m:psimax_init:
   mAnalyseEPairs = maxdom_analyseEPairs()
   nmax = ("nmax=",val) in args
   maxdom_epair_init(nmax)
|
maxdom_m:maxdom_epair_init:
   allocate mEPairStat(nmax) ! array of simplestats
|
qmc_m:qmc_run:
    if (mMaxSearch.and.step==mBlockSize): psimax_opt()
   |
   psimax_m:psimax_opt:
      if mAnalyseEPairs==1:
         psimax_addToDomainAndList:
            mpi_gather
            MASTER only: maxdom_collectEPairs
      if mAnalyseEPairs==2:
         psimax_addToEnergies():
            mRV_p%getIdxAndPermutation(n,idx2); idx2 -> asgn
            maxdom_collectEPairs
   |
   if (maxDomainSampling):
      maxdom_writeToFiles: including epairs (new parallel, old serial)

  
==================================================================

(3) wave function parameter optimizations (NEEDS UPDATE):

$optimize_parameters:
|
optimizeparams_m: optimizeParameters(optMethod, optMode, params: optType=[ci,jastrow,mo])
   |
   wfparameters_m: wfparams_init(WFP,optType,optMode)
      |
      WFP: wave function parameter data structure
      select(optType):
      npJ = jastrow_m:getJastrowParamCnt()
      mdetparam_m:mdetparam_create()
      * mdetparam_m: fk(:),fkgrad(:),fklapl(:)
      npCI = mdetparam_m:getCIParamsCnt
      moparam_m:moparam_create()
      npMO = moparam_m:getMOParamsCnt

      select(optMethod):
      optimizeParamsENR_m: eminNR_optimizeSample(lines,nl,wfp_p,sample,converged)
      ...
         |
         elocandpsitermsENR_m:ElocAndPsiTermsENR_create(EPsiTENR,eRef,WFP)
         * elocandpsitermsENR_m:EPsiTENR data structure: fi(:),fiEL(:) etc.
         |
         optimization loop (eq_iter):
            |
            walker_loop (rwp):                              ! note: single walkers not walker block, block is possible!
               pos(rwp,x,y,z)
               rwp%resetTo(x,y,z,optType)                   ! recalculating eloc and eloc terms (why not rwp%recalculate?)
               ElocAndPsiTermsENR_add(EPsiTENR):
                  ElocAndPsiTermsENR_addJastrow():
                     |
                     * fi(:) = jastrowparamdata:ukgrad, eloc:elxDrift       ! ukgrad etc one walker only!
                  ElocAndPsiTermsENR_addCI():
                     |
                     mdetparams_m:mdetcalcderivs():
                        | 
                        * fkgrad(:) etc

            ElocAndPsiTermsENR_resultALL(EPsiTENR,fi,ELi,fiEL,fij,fifj,fijEL,fifjEL,fiELj):
               |
               collect estimators with reduce

            calculate grad and Hessian

            modified Newton step

            wfparameters_m: wfparams_set(WFP,p):
               |
               jastrow_m: putJastrowParamVector(p)
               mdetparam_m: putCIParamVector(p)

            check convergence
         

====================================================================

(4) T move code (as of summer 2016)
note: implemented only for one walker in walker block rwb: rwb(1)

use:
   rw_setToBlock(rwb,ec,tmove,isMoved):
      if (present(tmove)):
         call eloc(ec,tmove,isMoved)
      else:
         call (eloc(ec))
      rwb%x/y/z = eConfigArray_get(ec,x,y,z)
      rwb%eLocal = elEloc
      etc.

propagator_m.f90: propagateAndWeightAll(Randomwalker(:) rwb)
   |
   reyProp(rwb)      !! or umrProp
      |
      mRWSave = rwb
      ecNew = (calculate drift-diffusion step)

      if (mTmove>0):
         call rw_setToBlock(rwb,ecNew,tmove,isMoved)
         if (isMoved(1)): 
            call rw_setToBlock(mRWTMoves(1:1), ecNew)   !! i.e. no new T move calc
      else:
         call rw_setToBlock(rwb,ecNew)

      calculate AR probability

   possibly reject: rwb(1) = mRWSave

   mTMoveW==1: rwb(1) = mRWTMoves(1)   !! now: E_local(rwb) from TMove position

   weighting with E_local(rwb) and E_local(mRWSave)

   mTMoveW==0: rwb(1) = mRWTMoves(1)
   
   


