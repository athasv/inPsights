head	1.1;
access;
symbols;
locks
	luechow:1.1; strict;
comment	@# @;


1.1
date	2011.11.15.21.36.17;	author luechow;	state Exp;
branches;
next	;


desc
@initial version GTO to STO fit
@


1.1
log
@Initial revision
@
text
@from numpy import *
from scipy import integrate
from scipy import linalg
from scipy import special
from scipy import optimize

#
class Gfctn:
    n = 1
    alpha = 1
    def __init__(self,n,alpha):
        self.alpha = alpha
        self.n = n
    def __call__(self,r):
        return r**self.n*exp(-r-self.alpha*r**2)
        
    def value(self,r):
        return r**self.n*exp(-r-self.alpha*r**2)
    def integral(self):
        return integrate.quad(self,0,Inf)[0]


class RGfctn:
    alpha = 1
    def __init__(self,alpha):
        self.alpha = alpha
    def __call__(self,r):
        return r**2*(4.0/(2*pi)**0.25 * self.alpha**0.75 * exp(-self.alpha*r**2))**2

class STO2fctn:
    n = 1
    def __init__(self,n):
        self.n = n
    def __call__(self,r):
        fak = 1
        for i in range(2,2*self.n+1):
            fak *= i
        normSTO = fak**(-0.5) * 2**(self.n+0.5)
        return r**2*(normSTO * r**(self.n-1) * exp(-r))**2

def Sij(alpha,i,j):
    return ( (2*sqrt(alpha[i]*alpha[j])) / (alpha[i]+alpha[j]) )**1.5


def Pi(nSTO,alpha):
    fak = 1
    for i in range(2,2*nSTO+1):
        fak *= i
    normSTO = fak**(-0.5) * 2**(nSTO+0.5)
    normGTO = 4.0/(2*pi)**0.25 * alpha**0.75
    gf = Gfctn(nSTO+1,alpha)
    g = gf.integral()
    return normSTO*normGTO*g

def calcCoeffs(nSTO,alpha):
    """calc Coeffs implements lsq minimization according to
       O-Ohata, Taketa, Huzinaga, JPSJ, 21, 2306, 1966"""
    P = zeros(len(alpha),'d')
    S = zeros((len(alpha),len(alpha)),'d')
    c = zeros(len(alpha),'d')
    for i in range(len(alpha)):
        P[i] = Pi(nSTO,alpha[i])
        for j in range(i,len(alpha)):
            S[i,j] = ( (2*sqrt(alpha[i]*alpha[j])) / (alpha[i]+alpha[j]) )**1.5
            S[j,i] = S[i,j]
    c = linalg.solve(S,P)
    V = 1 - sum(c*P)
    return V,c

def GTOSTOOptim(nSTO,nGTO,a0):
    """GTOSTOOptim implements alpha mapping with Legendre polys
       to prevent near linear dependency, G. A. Petersson, JCP 118, 1101, 2003"""
    alpha = zeros(nGTO,'d')
    for j in range(nGTO):
        lna = 0
        for k in range(len(a0)):
            lna += a0[k]*eval_legendre(k,(2*j-2)/(nGTO-1) - 1.0)
        alpha[j] = exp(lna)
    V,c = calcCoeffs(nSTO,alpha)
    

# Todo: class! mit a0, alpha, und c
# calcAlphaAndCoeffs(a0) return only V
# optimize with fmin (Nelder-Mead)
# get method for c and alpha
# improve import! read syntax!

RG = RGfctn(2.0)
i2 = integrate.quad(RG,0,Inf)
assert abs(i2[0]-1)<1.e-8,"GTO not normalized"

stot = STO2fctn(3)
i3 = integrate.quad(stot,0,Inf)
stot = STO2fctn(1)
i4 = integrate.quad(stot,0,Inf)
assert abs(i3[0]-1.0)<1.e-8,"STO not normalized"
assert abs(i4[0]-1.0)<1.e-8,"STO not normalized"


g1 = Gfctn(1,1.0)
r = 0.0
print g1(r)
print g1(1.0)
print g1.integral()

g1 = Gfctn(2,2.0)
print g1.integral()

print "testing calcCoeffs:"
print calcCoeffs.__doc__

alpha = array([7.2337,1.27973,0.331608,0.10141])
V4,c4 = calcCoeffs(1,alpha)
print "V=",V4
print "c=",c4

alpha = array([1188.35,156.411,37.9276,10.5140,3.34954,1.18834,0.458596,
               0.191073,0.0848076,0.0372356])
V10,c10 = calcCoeffs(1,alpha)
print "V=",V10
print "c=",c10

print "testing GTOSTOOptim:"
print GTOSTOOptim.__doc__




@
