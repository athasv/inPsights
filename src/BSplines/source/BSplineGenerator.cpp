//
// Created by Michael Heuer on 10.05.16.
//

#include "BSplineGenerator.h"
#include "BSplineFromPenalizedLeastSquaresFitWithFixedEnds.h"
#include <iostream>

/* Constructor for BSplineFromControlPolygon and BSplineFromPointInterpolation */
BSplineGenerator::BSplineGenerator(const Eigen::MatrixXd & dataPoints,
                                   const unsigned splineDegree)
  :
  p_(splineDegree),
  dim_((unsigned) dataPoints.cols()),
  m_((unsigned) dataPoints.rows()-1),
  n_(m_),
  R_(dataPoints)
{
  assert( (n_ >= p_) && (p_>=1) );
}

/* Constructor for BSplineFromPenalizedLeastSquaresFitWithFixedEnds */
BSplineGenerator::BSplineGenerator(const Eigen::MatrixXd & dataPoints,
                                   const unsigned numberOfControlPoints,
                                   const unsigned splineDegree)
:
  p_(splineDegree),
  dim_((unsigned) dataPoints.cols()),
  m_((unsigned) dataPoints.rows()-1),
  n_(numberOfControlPoints-1),
  R_(dataPoints)
{
  assert( (p_ >= 1) && "The spline degree p must be at least 1.");
  assert( (n_ >= p_) && "The number polynomial segments n must be greater or equal to the spline degree.");
  assert( (m_ > n_) && "The number of data segments m has to be greater than "
                         "the number of requested polynomial segments n.");
}


BSpline BSplineGenerator::generateBSpline(int highestDerivativeOrder){
  assert( ( highestDerivativeOrder<=int(p_) ) && ( highestDerivativeOrder>=-1 ) &&
          "highestDerivativeOrder k has to be <= splineDegree p. "
            "For -1 the highestDerivativeOrder k = p_ and all possible derivatives are calculated");
  return BSpline(U_,P_,p_,highestDerivativeOrder);
}

void BSplineGenerator::generateParametersByChordLengthMethod() {
  double sum=0;
  uBar_.resize(R_.rows(),1);
  uBar_.setZero();

  for (unsigned g = 1; g <= m_; ++g) {
    Eigen::VectorXd diff = R_.row(g)-R_.row(g-1);
    sum += diff.norm();
  }

  uBar_(0)=0;
  for (unsigned g = 1; g <= m_-1; ++g) {
    uBar_(g) = uBar_(g-1);
    Eigen::VectorXd diff = R_.row(g)-R_.row(g-1);
    uBar_[g]+= diff.norm()/sum;
  }
  uBar_(m_)=1;
}

void BSplineGenerator::generateParametersByCentripetalMethod() {
  double sum=0;
  uBar_.resize(R_.rows(),1);
  uBar_.setZero();

  for (unsigned g = 1; g <= m_; ++g) {
    Eigen::VectorXd diff = R_.row(g)-R_.row(g-1);
    sum += sqrt(diff.norm());
  }

  uBar_(0)=0;
  for (unsigned g = 1; g <= m_-1; ++g) {
    uBar_(g) = uBar_(g-1);
    Eigen::VectorXd diff = R_.row(g)-R_.row(g-1);
    uBar_[g]+= sqrt(diff.norm())/sum;
  }
  uBar_(m_)=1;
}

void BSplineGenerator::generateParametersByEquallySpacedMethod() {
  uBar_.resize(R_.rows(),1);
  uBar_.setZero();

  uBar_(0)= 0;
  for (unsigned g = 1; g <= m_-1; ++g) {
    uBar_[g] = double(g)/double(m_);
  }
  uBar_(m_)= 1;
}

void BSplineGenerator::generateKnotVectorByDeBoorsMethod() {
  /* For the least squares fitting, parameters must be generated by the chord-length method. Otherwise the resulting
   * system of linear equations would be singular.
   * */
  U_.resize(n_+p_+2);
  U_.setZero();
  double d,alpha;

  /*! set the first p+1 knots with zeros*/
  for (unsigned h = 0; h <= p_; ++h) { U_(h) = 0; }

  /*! calculate the internal knots by de Boor algorithm */ //TODO is this the same algorithm as in BSpline.cpp?
  for (unsigned j = 1; j <= n_-p_; ++j) {
    unsigned i;
    d = double(m_+1)/double(n_-p_+1);
    i = static_cast<unsigned>(j*d);
    alpha = j*d-i;
    U_(p_+j) = (1-alpha)*uBar_(i-1) + alpha*uBar_(i);
  }

  /*! set the last p+1 knots with ones*/
  for (unsigned h = n_+1; h <= n_+p_+1; ++h) { U_(h) = 1; }
}

void BSplineGenerator::generateKnotVectorByUniformMethod() {
  U_.resize(n_+p_+2);
  U_.setZero();

  /*! set the first p+1 knots with zeros*/
  for (unsigned h = 0; h <= p_; ++h) { U_(h) = 0; }

  /*! calculate the internal knots*/
  for (unsigned j = 1; j <= n_-p_; ++j) { U_(j+p_) = double(j)/double((n_-p_+1)); }

  /*! set the last p+1 knots with ones*/
  for (unsigned h = n_+1; h <= n_+p_+1; ++h) { U_(h) = 1; }
}

void BSplineGenerator::generateKnotVectorByKnotAveraging() {
  U_.resize(n_+p_+2);
  U_.setZero();

  double parameterSum;

  /*! set the first p+1 knots with zeros*/
  for (unsigned h = 0; h <= p_; ++h) { U_(h) = 0; }

  /*! calculate the internal knots by knot averaging */
  for (unsigned j = 1; j <= n_-p_; ++j) {
    parameterSum = 0.0;
    for (unsigned i = j; i <= j+p_-1; ++i) {
      parameterSum += uBar_[i];
    }
    U_(j+p_) = parameterSum/double(p_);
  }

  /*! set the last p+1 knots with ones*/
  for (unsigned h = n_+1; h <= n_+p_+1; ++h) { U_(h) = 1; }
}

void BSplineGenerator::setSplineDegree(const unsigned int splineDegree) {
  p_=splineDegree;
  initializeGenerator();
}

void BSplineGenerator::setDataPoints(Eigen::MatrixXd dataPoints) {
  R_=dataPoints;
  initializeGenerator();
}
